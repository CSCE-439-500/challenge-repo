import hashlib
import logging
from pathlib import Path
from typing import Tuple, Optional

from ..core.guards import guard_can_write, require_redteam_mode

logger = logging.getLogger(__name__)


def generate_embedded_payload_module(
    obfuscated_data: bytes,
    output_path: Path,
    module_name: str = "embedded_payload",
    embedded_key: Optional[bytes] = None,
) -> Tuple[str, str]:
    """Generate a Python module containing the obfuscated PE payload as bytes.

    Args:
        obfuscated_data: The obfuscated PE binary data
        output_path: Where to write the generated module
        module_name: Name of the module (default: "embedded_payload")

    Returns:
        Tuple of (module_path, payload_hash) for audit trail
    """
    require_redteam_mode()
    guard_can_write()

    payload_hash = hashlib.sha256(obfuscated_data).hexdigest()
    payload_size = len(obfuscated_data)

    # Generate the module content
    key_repr = repr(embedded_key if embedded_key is not None else b"")

    module_content = f'''"""Embedded obfuscated PE payload module.

Generated by rt_evade embed tool.
Payload hash: {payload_hash}
Payload size: {payload_size} bytes
"""

EMBEDDED_PAYLOAD = {obfuscated_data!r}
EMBEDDED_KEY = {key_repr}
PAYLOAD_HASH = "{payload_hash}"
PAYLOAD_SIZE = {payload_size}
'''

    output_path.write_text(module_content, encoding="utf-8")
    logger.info(
        "action=embed_payload module=%s size=%d hash=%s",
        output_path,
        payload_size,
        payload_hash,
    )

    return str(output_path), payload_hash


def load_embedded_payload(module_name: str = "embedded_payload") -> bytes:
    """Load the embedded payload from the generated module.

    Args:
        module_name: Name of the embedded payload module

    Returns:
        The obfuscated payload bytes
    """
    try:
        module = __import__(module_name, fromlist=["EMBEDDED_PAYLOAD"])
        return module.EMBEDDED_PAYLOAD
    except ImportError as e:
        raise RuntimeError(f"Failed to load embedded payload module '{module_name}': {e}")


def load_embedded_payload_and_key(module_name: str = "embedded_payload") -> Tuple[bytes, bytes]:
    """Load the embedded payload and key; works with import or file fallback.

    Tries import first; if unavailable (e.g., in packaged onefile with data), attempts
    to locate a sibling `embedded_payload.py` near the executable or in PyInstaller's
    _MEIPASS directory.
    """
    try:
        module = __import__(module_name, fromlist=["EMBEDDED_PAYLOAD", "EMBEDDED_KEY"])
        return module.EMBEDDED_PAYLOAD, getattr(module, "EMBEDDED_KEY", b"")
    except Exception:
        pass

    import sys
    import types

    candidates = []
    exe_dir = Path(getattr(sys, "_MEIPASS", Path(sys.argv[0]).resolve().parent))
    candidates.append(exe_dir / f"{module_name}.py")
    candidates.append(Path(sys.argv[0]).resolve().parent / f"{module_name}.py")

    for path in candidates:
        if path.exists():
            ns: dict[str, object] = {}
            code = path.read_text(encoding="utf-8")
            exec(compile(code, str(path), "exec"), ns)
            payload = ns.get("EMBEDDED_PAYLOAD", b"")
            key = ns.get("EMBEDDED_KEY", b"")
            if isinstance(payload, (bytes, bytearray)):
                return bytes(payload), bytes(key) if isinstance(key, (bytes, bytearray)) else b""

    raise RuntimeError("Embedded payload not found")
